#+TITLE: Developer's Manual
#+AUTHOR: 
* Adding a Proposal
  1. add a file called Proposal.cpp and Proposal.hpp to the folder proposals (maybe just copy the template)
  2. refresh the sources for the Makefile as follows:
     #+BEGIN_SRC bash
$ make my-update-src  
     #+END_SRC
  3. implement (specifically the purely virtual methods)
  4. add an id for your proposal to ProposalType.hpp
  5. initialize your proposal in ProposalRegistry.hpp (don't forget the header file)
  6. to add your proposal to the default startup, add your proposal id to 
     #+BEGIN_SRC c
     std::vector<ProposalType> getProposalsForCategory(Category c) 
     #+END_SRC
  7. add the a string representation for the config file in the
     function below. Your proposal can now be enabled from the config
     file, but will not show up by default (that's what you
     need 6. for)
     #+BEGIN_SRC c
     std::string getConfigStringFromType(ProposalType p )
     #+END_SRC
  8. in ProposalType.cpp: add your proposal to getSingleParameterProposalsForCategory
  9. in ProposalType.cpp: by adding your proposal to you can control,
     whether using the proposal is suppressed. By default new
     proposals are only instantiated, if this function returns true
     for the respective proposal.
  10. when you call exabayes now, your proposal can be
      instantiated. You have to add your proposal to a few additional
      places. The easiest thing is to just call the program and check,
      where assertions fail.
* Build Process Caveats
  1. on some of our group servers the clock is not set properly. If
     the build system complains about times, simply touch everything
     until it works 
     #+BEGIN_SRC bash
$ touch $(find . )
     #+END_SRC
  2. out-dated dependencies can mess up the build process, thus:      
     #+BEGIN_SRC bash
$ rm -rf .deps
     #+END_SRC
  3. the defaultRun.sh script will save the last configure call into
     the file status. If you aborted the configure process or somehow
     the whole process got stuck, it is a good idea to delete the
     status file and thus enforce a new configure
  4. exabayes should work with >gcc-4.6 or >clang-3.2
  5. for a build with the ExaML code base, defaultRun.sh needs mpich2
  6. If you want to install ExaBayes on another machine, where you
     have less administrative capabilities, it is a good idea, to
     create a tar-ball with
     This tar-ball should be definitely configure-able, it must be
     independent from autoconf/automake system. 
     #+BEGIN_SRC bash 
$ make dist 
     #+END_SRC
  7. you may create a distinct build directory like this:
     #+BEGIN_SRC bash 
$ mkdir build 
$ cd build 
$ ../configure && make  
     #+END_SRC   
  8. if autosave-files have been created that contain #, this may mess
     up the source-refreshing process. Check out (and repair) the file
     that contains all sources (src.am) 
  9. occasionally you may encounter weird error messages after linking
     that indicate that the various functions could not be found. If
     you can rule out other sources of error (e.g., you did not
     implement the method), then one of the earlier linking steps
     could have gone wrong.
  10. install ccache. It will speed up re-compiling. defaultRun.sh
      knows how to handle it. ccache should never influence the
      compilation result. However, if something like in (9.)  has gone
      wrong, ccache will cache it. You should delete the cache then  
     #+BEGIN_SRC bash 
$ ccache -C  
     #+END_SRC
* Good git practices
** Branches are Always Underused
   A good workflow is something like this:      
   1. create a branch for implementing a new feature or trying
      something out (you should be on branch master to do so):
     #+BEGIN_SRC bash
$ git checkout -b newFeature # create new branch 
      #+END_SRC
   2. implement the feature. Commit often, such that it is easy to
      reset, if something went wrong.
   3. Merge your feature into the master. You can squash all your
      commits into one message.
#+BEGIN_SRC bash 
$ git checkout master 
$ git merge --squash
$ git commit -a -m "This is my new feature..." 
#+END_SRC
** detached HEAD
   If you checked out a specific commit, it may be confusing how to
   get back to the original branch. That's actually just:
   #+BEGIN_SRC bash
$ git checkout master # or any other branch 
$ # or
$ git reset --hard master  
   #+END_SRC
** resetting your working copy
   #+BEGIN_SRC bash
$ git reset --hard
   #+END_SRC
** quickly saving your modifications for later without commiting
   #+BEGIN_SRC bash
$ git stash 
$ git stash pop # restore 
   #+END_SRC
* ExaBayes style guide 
Due to the size of the code-base and a rapidly changing style, these
guidelines have not been implemented at all places in the code. Please
extend, if you come across outdated sections.
** initialization:
   the favored (i.e., most save) form of variable initialization is:
#+BEGIN_SRC C++
auto Object = Object{}; 
auto Object = Object{1,2,3};

auto &&iss = std::istringstream{ fileName };

// also holds for constructors
Object::Object(int i, int j)
 :  _i{i}
 ,  _j{j}
{
}

// maybe let's go to primitive types for consistency as well: 
auto isTrue = bool{true}; 

// only use the round brackets, when there really is a  reason for that: 
auto myInts = std:vector<int>(3,7);
auto myInt = int(3.7);

#+END_SRC
Check out herb sutter's respective site:  
http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/
** make protected / private variables visible: 
   Use an initial dash to underline the scope of the variables
#+BEGIN_SRC c++
class Object
{
  private: 
  int _i; 
  int _j; 
}; 
#+END_SRC
** always return tuple return values
if your function has a true output parameter, then return it (as a tuple) and catch it with a std::tie when calling the function
#+BEGIN_SRC c++
auto function()
  -> std::tuple<std::unique_ptr<int>,int>
{
  // auto&& tmp = std::unique_ptr<int>{ new int }; 
  int foo = 3; 
  *tmp = 4; 
  return std::make_tuple(std::move(tmp),foo);
}

int main(int argc, char **argv)
{
  int myFoo; 
  auto &&myTmp = std::unique_ptr<int>{}; 

  std::tie(myTmp,myFoo) = function(); 
  std::cout << myFoo << "\t"  << *myTmp << std::endl; 
}
#+END_SRC
Still, input-output parameters should not be returned.   
*** Don't use std::pair. 
    Having tuples and pairs only makes things more complicated, when a
    tuple is a super-set of a pair.
** don't use "using namespace std;"
** objects 
1. construct your objects as light-weight as possible (w.r.t. member variables and functions)
2. favor composition over inheritance
