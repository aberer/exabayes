/** 
    @file exabayes.cpp
    
    @brief This file sets the flavour of exabayes that has been
    compiled (i.e., sequential, pll, examl, ...)
    
*/ 



// TODO re-activate all that initial bla bla when starting up
// exa-bayes (model / program info )


#ifdef HAVE_AVX
#define __AVX
#endif

#include <iostream>
#include <sstream>
#include <chrono>

#include "releaseDate.hpp" 

#include "time.hpp"

#include "config/CommandLine.hpp"
#include "mcmc/SampleMaster.hpp"
#include "comm/ParallelSetup.hpp"

#include "TeeStream.hpp"




/* 
   tell the CPU to ignore exceptions generated by denormalized floating point values.
   If this is not done, depending on the input data, the likelihood functions can exhibit 
   substantial run-time differences for vectors of equal length.
*/

static void ignoreExceptionsDenormFloat()
{
#if ! (defined(__ppc) || defined(__powerpc__) || defined(PPC))
  _mm_setcsr( _mm_getcsr() | _MM_FLUSH_ZERO_ON);
#endif   
}


static bool fileExists(const std::string &name)
{
  auto &&ifh = std::ifstream{name};
  bool result = ifh.is_open(); 
  ifh.close();
  return result; 
}



void initLogFile(const ParallelSetup &pl, std::string logFile )
{
  if( pl.isGlobalMaster())
    globals.logStream =  make_unique<std::ofstream>(logFile); 
  else 
    globals.logStream = make_unique<std::ofstream>(std::string{"/dev/null"}); 
    
  globals.teeOut =  make_unique<TeeStream>(std::cout, *globals.logStream, MY_TID);

  if(not pl.isGlobalMaster())
    globals.teeOut->disable();

}





static void initializeProfiler(const ParallelSetup& pl)
{
  // see this page for info 
  // http://google-perftools.googlecode.com/svn/trunk/doc/cpuprofile.html  
  // that option is important
  // CPUPROFILE_FREQUENCY=x
#ifdef _USE_GOOGLE_PROFILER
  auto&& ss = std::stringstream {}; 
  ss << "profile.out." << pl.getGlobalRank() ; 
  auto myProfileFile = ss.str(); 
  remove(myProfileFile.c_str()); 
  ProfilerStart(myProfileFile.c_str()); 
#endif
}

 
void finalizeProfiler()
{
#ifdef _USE_GOOGLE_PROFILER
  ProfilerStop();
#endif
}



static void printInfoHeader(CommandLine& cl)
{  
  // auto &&sout = SyncOut();
  auto &&ss = std::stringstream{}; 

  ss << "\n"; 

  ss << "This is "; 
  if(isYggdrasil)
    ss << "Yggdrasil, the sequential variant of "; 

  ss << PROGRAM_NAME << " (version " << VERSION << "),\n"; 
  ss << "a tool for Bayesian MCMC sampling of phylogenetic trees, build with the" ; 

  ss << "\nPhylogenetic Likelihood Library (version " << PLL_LIB_VERSION << ", " << PLL_LIB_DATE << ")" ; 
  if(not isYggdrasil)
    ss << " and MPI-support."; 
  else 
    ss << "."; 

  ss <<  "\nThis software has been released in " << RELEASE_DATE <<  " by \n\n\tAndre J. Aberer, Kassian Kobert and Alexandros Stamatakis\n" 
       << "\nPlease send any bug reports, feature requests and inquiries to " << PACKAGE_BUGREPORT << "\n\n"; 

  ss << "The program was called as follows: \n" ; 
  ss << cl.getCommandLineString() << "\n" ; 
  ss << "\n================================================================\n" ; 

  tout << ss.str() ; 
}



// also the entry point for the threads

/**
   @brief the main ExaBayes function.

   @param tr -- a tree structure that has been initialize in one of the adapter mains. 
   @param adef -- the legacy adef
 */
void exa_main ( CommandLine &cl, ParallelSetup* pl  )
{   

  auto && ss = std::stringstream();
  // ss << *pl << "\n\n"; 
  
  ss <<  *pl << "\n\n"; 
  std::cout << SyncOut() << ss.str(); 

  ignoreExceptionsDenormFloat(); 

  initializeProfiler(*pl);

  printInfoHeader(cl); 

  timeIncrement = CLOCK::system_clock::now(); 

  auto&& master = SampleMaster();
  
  master.setParallelSetup(pl); 
  master.setCommandLine(cl); 

  master.initializeRuns(Randomness(cl.getSeed())); 
  if( cl.isDryRun())
    {
      std::cout << "Command line, input data and config file is okay. Exiting gracefully." << std::endl; 
      exitFunction(0);
    }
  else 
    {
      master.run();
      master.finalizeRuns();
    }

  finalizeProfiler();
}


void makeInfoFile(const CommandLine &cl, const ParallelSetup &pl )
{
  auto &&ss = stringstream{}; 

  if(cl.isDryRun())
    ss << "/dev/null" ; 
  else 
    ss << OutputFile::getFileBaseName(cl.getWorkdir()) << "_info."  << cl.getRunid() ;

  if( not cl.isDryRun() && pl.isGlobalMaster() )
    {
      if(fileExists(ss.str()))
	{
	  std::cerr << std::endl <<  "File " << ss.str() << " already exists (probably \n"
		    << "from previous run). Please choose a new run-id or remove previous output files. " << std::endl; 
	  exitFunction(-1); 
	}
    }

  initLogFile(pl, ss.str());
}

// just having this, because of mpi_finalize
static int innerMain(int argc, char **argv)
{ 
  auto cl = CommandLine(); 
  cl.initialize(argc, argv); 

  auto plPtr = make_unique<ParallelSetup>(cl); 

  plPtr->initialize();

  makeInfoFile(cl, *plPtr);

  plPtr->releaseThreads();

  exa_main(cl, plPtr.get()); 
  
  return 0;
}


void myExit(int code)
{
  ParallelSetup::abort(code); 
}


int main(int argc, char **argv)
{ 
#ifdef _IS_YGG
  isYggdrasil = true; 
  exitFunction = myExit; 
#else 
  isYggdrasil = false; 
  exitFunction = myExit; 
#endif  

  ParallelSetup::initializeRemoteComm(argc, argv);
  innerMain(argc, argv); 
  ParallelSetup::finalize(); 
  return 0 ; 
}
