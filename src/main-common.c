/**************************************************************************************/
/* NOTICE: contrary to its name, this file cannot be shared yet across pll and examl  */
/**************************************************************************************/

#include <stdio.h>
#include <unistd.h>
#include "axml.h"
#include "config.h"
#include "main-common.h"

#include "proposalStructs.h"
#include "globals.h" 
#include "common.h"



/* 
   tell the CPU to ignore exceptions generated by denormalized floating point values.
   If this is not done, depending on the input data, the likelihood functions can exhibit 
   substantial run-time differences for vectors of equal length.
*/
    
void ignoreExceptionsDenormFloat()
{
#if ! (defined(__ppc) || defined(__powerpc__) || defined(PPC))
  _mm_setcsr( _mm_getcsr() | _MM_FLUSH_ZERO_ON);
#endif   
}


 void printREADME()
{
  printf("TODO\n"); 
}

void initAdef(analdef *adef)
{   
  adef->max_rearrange          = 21;
  adef->stepwidth              = 5;
  adef->initial                = 10;
  adef->bestTrav               = 10;
  adef->initialSet             = FALSE; 
  adef->mode                   = BIG_RAPID_MODE; 
  adef->likelihoodEpsilon      = 0.1;
 
  adef->permuteTreeoptimize    = FALSE; 
  adef->perGeneBranchLengths   = FALSE;  
 
  adef->useCheckpoint          = FALSE;
   
#ifdef _BAYESIAN 
  adef->bayesian               = FALSE;
#endif
}


void printVersionInfo()
{
#if (HAVE_PLL == 1 ) 
  PRINT("This is %s, version %s built with the phlogenetic likelihood library.\n", PROGRAM_NAME, VERSION); 
#else 
  PRINT("This is %s, version %s\n", PROGRAM_NAME, VERSION); 
#endif  
}




void analyzeRunId(char id[128])
{
  int i = 0;

  while(id[i] != '\0')
    {
      if(i >= 128)
	{
	  printf("\n Error: run id after \"-n\" is too long, it has %d characters please use a shorter one\n\n", i);
	  assert(0);
	}

      if(id[i] == '/')
	{
	  printf("\n Error: character %c not allowed in run ID\n\n", id[i]);
	  assert(0);
	}


      i++;
    }

  if(i == 0)
    {
      printf("\n Error: please provide a string for the run id after \"-n\" \n\n");
      assert(0);
    }
}



int filexists(char *filename)
{
  FILE
    *fp;
  
  int
    res;
  
  fp = fopen(filename,"rb");

  if(fp)
    {
      res = 1;
      fclose(fp);
    }
  else
    res = 0;

  return res;
}



void errorExit(int e)
{
#if  (HAVE_PLL == 0 )
  MPI_Finalize();
#endif

  exit(e);
}



void finalizeFiles()
{
  PRINT("TODO\n"); 
}




int mygetopt(int argc, char **argv, char *opts, int *optind, char **optarg)
{
  static int sp = 1;
  register int c;
  register char *cp;

  if(sp == 1)
    {
      if(*optind >= argc || argv[*optind][0] != '-' || argv[*optind][1] == '\0')
	return -1;
    }
  else
    {
      if(strcmp(argv[*optind], "--") == 0)
	{
	  *optind =  *optind + 1;
	  return -1;
	}
    }

  c = argv[*optind][sp];
  if(c == ':' || (cp=strchr(opts, c)) == 0)
    {
      printf(": illegal option -- %c \n", c);
      if(argv[*optind][++sp] == '\0')
	{
	  *optind =  *optind + 1;
	  sp = 1;
	}
      return('?');
    }
  if(*++cp == ':')
    {
      if(argv[*optind][sp+1] != '\0')
	{
	  *optarg = &argv[*optind][sp+1];
	  *optind =  *optind + 1;
	}
      else
	{
	  *optind =  *optind + 1;
	  if(*optind >= argc)
	    {
	      printf(": option requires an argument -- %c\n", c);
	      sp = 1;
	      return('?');
	    }
	  else
	    {
	      *optarg = argv[*optind];
	      *optind =  *optind + 1;
	    }
	}
      sp = 1;
    }
  else
    {
      if(argv[*optind][++sp] == '\0')
	{
	  sp = 1;
	  *optind =  *optind + 1;
	}
      *optarg = 0;
    }
  return(c);
}


/* TODO consolidate */
void get_args(int argc, char *argv[], analdef *adef, tree *tr)
{
  boolean
    bad_opt    = FALSE,
    resultDirSet = FALSE;

  char
    resultDir[1024] = "",          
    *optarg,
    model[1024] = ""
  ;

  double 
    likelihoodEpsilon;
  
  int     
    optind = 1,        
    c,
    nameSet = 0,
    treeSet = 0,   
    modelSet = 0, 
    byteFileSet = 0;


  /*********** tr inits **************/ 
 
  tr->doCutoff = TRUE;
  tr->secondaryStructureModel = SEC_16; /* default setting */
  tr->searchConvergenceCriterion = FALSE;
  tr->rateHetModel = GAMMA;
 
  tr->multiStateModel  = GTR_MULTI_STATE;
#if (HAVE_PLL == 0 ) 
    tr->useGappedImplementation = FALSE;
    tr->saveBestTrees          = 0;
#endif
  tr->saveMemory = FALSE;

  tr->manyPartitions = FALSE;

  tr->categories             = 25;

  tr->grouped = FALSE;
  tr->constrained = FALSE;

  tr->gapyness               = 0.0; 


  tr->useMedian = FALSE;

  int seed = -1 ;

  strcpy(configFileName, "\0");

  /* legacy  */
  strcpy(model, "GAMMA"); 
  modelSet = 1; 

  /********* tr inits end*************/




  while(!bad_opt && ((c = mygetopt(argc,argv,"T:e:c:f:i:t:w:n:s:vhMQap:", &optind, &optarg))!=-1))
    {
    switch(c)
      {    
      case 'a':
	tr->useMedian = TRUE;
	break;
      case 'Q':
	tr->manyPartitions = TRUE;   	
	break;
      case 's': 
	strcpy(byteFileName, optarg);	 	
	byteFileSet = TRUE;
	break;      
      case 'M':
	adef->perGeneBranchLengths = TRUE;
	break;                                 
      case 'e':
	sscanf(optarg,"%lf", &likelihoodEpsilon);
	adef->likelihoodEpsilon = likelihoodEpsilon;
	break;          
      case 'v':
	printVersionInfo();
	errorExit(0);
      
      case 'h':
	printREADME();
	errorExit(0); 
      case 'i':
	sscanf(optarg, "%d", &adef->initial);
	adef->initialSet = TRUE;
	break;
      case 'n':
        strcpy(run_id,optarg);
	analyzeRunId(run_id);
	nameSet = 1;
        break;
      case 'w':
        strcpy(resultDir, optarg);
	resultDirSet = TRUE;
        break;
      case 'T':
#ifdef _USE_PTHREADS
	sscanf(optarg,"%d", &(tr->numberOfThreads));
#else
	printf("Option -T does not have any effect with the sequential or parallel MPI version.\n");
	printf("It is used to specify the number of threads for the Pthreads-based parallelization\n");
#endif
	break;
      case 't':
	strcpy(tree_file, optarg); 
	treeSet = 1;       
	break;     
      case 'c': 
	strcpy(configFileName, optarg); 
	break; 
      case 'p': 
	{
	  seed = atoi(optarg);
	  gAInfo.rGlobalKey.v[0] = seed; 
	  gAInfo.rGlobalKey.v[1] = 0xbadcafe; /* how funny */
	  break; 
	}
      default:
	errorExit(-1);
      }
    }

  
  if(strlen(configFileName) == 0 ||  ! filexists(configFileName) )
    {
      if(processID == 0)
	printf("\nPlease provide a config file via -C <file>. A testing file is available under  \n"); 
      errorExit(-1); 
    }

  
  if(seed == -1 )
    {
      if(processID == 0)
	printf("\nPlease provide a proper seed for the initialization of the random number generator. \n "); 
      errorExit(-1); 
    }

  if( ! filexists( configFileName))
    {
      if(processID == 0 )
  	printf("\nPlease provide a minimal config file via -C <file>.\n");
      errorExit(-1);
    }


  if(!byteFileSet)
    {
      if(processID == 0)
	printf("\nError, you must specify a binary format data file with the \"-s\" option\n");
      errorExit(-1);
    }

  if(!modelSet)
    {
      if(processID == 0)
	printf("\nError, you must specify a model of rate heterogeneity with the \"-m\" option\n");
      errorExit(-1);
    }

  if(!nameSet)
    {
      if(processID == 0)
	printf("\nError: please specify a name for this run with -n\n");
      errorExit(-1);
    }


  if( ! treeSet)
    {
      printf("no tree file provided, will use random trees as initial state.\n "); 
      char tmp[1024]; 
      tmp[0] = '\0'; 
      strcpy(tree_file, tmp); 
      gAInfo.numberOfStartingTrees = 0; 
      /* tree_file = "\0";  */
    }
  else 
    {
      FILE *fh = myfopen(tree_file, "r"); 
      gAInfo.numberOfStartingTrees = 0;  
      int ch; 

      while((ch = fgetc(fh)) != EOF)
	if(ch == ';')
	  gAInfo.numberOfStartingTrees++;
      
      printf("%d starting trees provided via -t\n", gAInfo.numberOfStartingTrees); 
    }

  /* if(!treeSet && !adef->useCheckpoint) */
  /*   { */
  /*     if(processID == 0) */
  /* 	{ */
  /* 	  printf("\nError: please either specify a starting tree for this run with -t\n"); */
  /* 	  printf("or re-start the run from a checkpoint with -R\n"); */
  /* 	} */
  /* errorExit(-1); */
  /* } */
  
   {

    const 
      char *separator = "/";

    if(resultDirSet)
      {
	char 
	  dir[1024] = "";
	

	if(resultDir[0] != separator[0])
	  strcat(dir, separator);
	
	strcat(dir, resultDir);
	
	if(dir[strlen(dir) - 1] != separator[0]) 
	  strcat(dir, separator);
	strcpy(workdir, dir);
      }
    else
      {
	char 
	  dir[1024] = "",
	  *result = getcwd(dir, sizeof(dir));
	
	assert(result != (char*)NULL);
	
	if(dir[strlen(dir) - 1] != separator[0]) 
	  strcat(dir, separator);
	
	strcpy(workdir, dir);		
      }
   }

  return;
}
