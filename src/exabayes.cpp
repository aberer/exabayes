/** 
    @file exabayes.cpp
    
    @brief This file sets the flavour of exabayes that has been
    compiled (i.e., sequential, pll, examl, ...)
    
*/ 



// TODO re-activate all that initial bla bla when starting up
// exa-bayes (model / program info )


#ifdef HAVE_AVX
#define __AVX
#endif

#include <iostream>
#include <sstream>
#include <chrono>


int NUM_BRANCHES; 


#define _INCLUDE_DEFINITIONS
#include "GlobalVariables.hpp"
#undef _INCLUDE_DEFINITIONS

#include "time.hpp"

#include "config/CommandLine.hpp"
#include "SampleMaster.hpp"
#include "ParallelSetup.hpp"

#include "teestream.hpp"

// #define TEST  

#include "axml.h" 

#ifdef TEST
#include "parameters/BranchLengthsParameter.hpp"
#include "TreeRandomizer.hpp"
#include "Chain.hpp"
#include "BranchLengthMultiplier.hpp"
#include "ParsimonyEvaluator.hpp"
#include "BoundsChecker.hpp"
#include "Bipartition.hpp"
#include "TreeAln.hpp"
#endif


// have ae look at that later again 
double fastPow(double a, double b)
{
  union 
  {
    double d;
    int x[2];
  } u = { a };
  u.x[1] = (int)(b * (u.x[1] - 1072632447) + 1072632447);
  u.x[0] = 0;
  return u.d;
}


/**
   @brief the main ExaBayes function.

  @param tr -- a tree structure that has been initialize in one of the adapter mains. 
   @param adef -- the legacy adef
 */
static void exa_main (const CommandLine &cl, const ParallelSetup &pl )
{   
  timeIncrement = CLOCK::system_clock::now(); 

#ifdef TEST     
  randCtr_t r; 
  r.v[0] = 123; 
  auto rand = Randomness (r);
  
  for(nat i = 0; i < 1000; ++i)
    {
      std::cout << rand.drawRandGamma(1,1000000) << std::endl;
    }

  exit(0); 
#else 
  // assert(0); 
  auto&& master = SampleMaster(  pl, cl );
  master.initializeRuns(); 
  if( cl.isDryRun())
    {
      std::cout << "Command line, input data and config file is okay. Exiting gracefully." << std::endl; 
      exit(0); 
    }
  else 
    {
      master.run();
      master.finalizeRuns();
    }
#endif
}


/* 
   tell the CPU to ignore exceptions generated by denormalized floating point values.
   If this is not done, depending on the input data, the likelihood functions can exhibit 
   substantial run-time differences for vectors of equal length.
*/

void ignoreExceptionsDenormFloat()
{
#if ! (defined(__ppc) || defined(__powerpc__) || defined(PPC))
  _mm_setcsr( _mm_getcsr() | _MM_FLUSH_ZERO_ON);
#endif   
}


void makeInfoFile(const CommandLine &cl, const ParallelSetup &pl )
{
  auto &&ss = stringstream{}; 

  if(cl.isDryRun())
    ss << "/dev/null" ; 
  else 
    ss << OutputFile::getFileBaseName(cl.getWorkdir()) << "_info."  << cl.getRunid() ;

  if( not cl.isDryRun() && pl.isGlobalMaster() && std::ifstream(ss.str()))
    {
      std::cerr << pl << std::endl; 
      std::cerr << std::endl <<  "File " << ss.str() << " already exists (probably \n"
		<< "from previous run). Please choose a new run-id or remove previous output files. " << std::endl; 
      ParallelSetup::genericExit(-1); 
    }

  globals.logFile = ss.str();   
  
  globals.logStream =  new ofstream  (globals.logFile); 
  globals.teeOut =  new teestream(cout, *globals.logStream);

  if(not pl.isGlobalMaster())
    tout.disable(); 
}


static void initializeProfiler(const ParallelSetup& pl)
{
  // see this page for info 
  // http://google-perftools.googlecode.com/svn/trunk/doc/cpuprofile.html  
  // that option is important
  // CPUPROFILE_FREQUENCY=x
#ifdef _USE_GOOGLE_PROFILER

#if HAVE_PLL != 0 
  auto myProfileFile = "profile.out"; 
  remove(myProfileFile);
  ProfilerStart(myProfileFile);
#else  
  auto&& ss = std::stringstream {}; 
  ss << "profile.out." << pl.getGlobalRank() ; 
  auto myProfileFile = ss.str(); 
  remove(myProfileFile.c_str()); 
  ProfilerStart(myProfileFile.c_str()); 
#endif

#endif
}

 
void finalizeProfiler()
{
#ifdef _USE_GOOGLE_PROFILER
  ProfilerStop();
#endif
}


static void printInfoHeader(int argc, char **argv)
{  
  tout << endl; 

  tout << "This is "
#if HAVE_PLL != 0
       << "Yggdrasil, the sequential variant of "
#endif
       << PROGRAM_NAME
       << " version " << VERSION
       << ", a tool for Bayesian MCMC sampling of phylogenetic trees," 
#if HAVE_PLL == 0 
       << "\nbuild with the ExaML code base and MPI-support."
#else 
       << "\nbuild with the (Phylogenetic Likelihood Library) PLL code base for sequential execution."
#endif

       << std::endl <<  "This software has been releasd by \n\tAndre J. Aberer, Kassian Kobert and Alexandros Stamatakis" << std::endl 
       << "in ?" << std::endl 

       << "\nPlease send any feature requests and inquiries to " << PACKAGE_BUGREPORT
       << std::endl << std::endl; 

  tout << PROGRAM_NAME << " was called as follows: " << endl; 
  for(int i = 0; i < argc; ++i)
    tout << argv[i] << " " ; 
  tout << endl 
       << "================================================================"
       << endl; 
}


int main(int argc, char **argv)
{ 
  auto pl = ParallelSetup(argc,argv); 		// MUST be the first thing to do because of mpi_init ! 

#if HAVE_PLL != 0 && ( (defined(_FINE_GRAIN_MPI) || defined(_USE_PTHREADS)))
  assert(0); 
#endif

  ignoreExceptionsDenormFloat(); 
  auto cl = CommandLine(argc, argv); 

#if HAVE_PLL == 0 
  pl.initializeExaml(cl);
#endif

  initializeProfiler(pl);

  makeInfoFile(cl, pl);

  printInfoHeader(argc,argv); 

  exa_main( cl, pl); 

  finalizeProfiler();
  pl.finalize();  
  
  delete globals.logStream; 
  delete globals.teeOut;
  return 0;
}
